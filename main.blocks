<xml xmlns="https://developers.google.com/blockly/xml"><block type="pxt-on-start" x="10" y="10"><statement name="HANDLER"><block type="typescript_statement" editable="false"><mutation xmlns="http://www.w3.org/1999/xhtml" line0="namespace Asynchronous {" line1="    export type Executor&lt;T&gt; = (resolve: (value: T) =&gt; void, reject: (reason?: any) =&gt; void) =&gt; void;" line2="    export type ThenHandler&lt;T, U&gt; = (value: T) =&gt; U | Promise&lt;U&gt;;" line3="    export type CatchHandler&lt;U&gt; = (reason?: any) =&gt; U | Promise&lt;U&gt;;" line4="    export class Promise&lt;T&gt; {" line5="        /**" line6="        * Runs code asynchronously, and returns a result" line7="        * @returns { Promise }" line8="        */" line9="        constructor(executor: Executor&lt;T&gt;) {" line10="            try {" line11="                executor((r: any) =&gt; this.resolve(r), (r: any) =&gt; this.reject(r)); // For Lambda bypass" line12="            } catch (error) {" line13="                this.reject(error);" line14="            };" line15="        };" line16="" line17="        /**" line18="         * Resolves the promise with the given value" line19="         * @param value The value for the promise" line20="         */" line21="        private resolve(value: T) {" line22="            if (this.state !== 'pending') return;" line23="            this.state = 'fulfilled';" line24="            this.value = value;" line25="" line26="            setTimeout(() =&gt; {" line27="                this.thenHandlers.forEach(handler =&gt; handler(value));" line28="            }, 0);" line29="        };" line30="" line31="        /**" line32="         * Rejects the promise with the given value" line33="         * @param value The value for the rejection" line34="         */" line35="        private reject(reason: any) {" line36="            if (this.state !== 'pending') return;" line37="            this.state = 'rejected';" line38="            this.reason = reason;" line39="" line40="            setTimeout(() =&gt; {" line41="                if (this.catchHandler) {" line42="                    this.catchHandler(reason);" line43="                } else {" line44="                    throw `Unhandled Promise rejection: ${reason}`;" line45="                };" line46="            }, 0);" line47="        };" line48="" line49="        /**" line50="         * Sets a callback for when the promise resolves" line51="         * @param onFulfilled The function to run when the promise is completed" line52="         * @returns { Promise&lt;U&gt; } The promise of the promise completion" line53="         */" line54="        then&lt;U&gt;(onFulfilled: ThenHandler&lt;T, U&gt;): Promise&lt;U&gt; {" line55="            return new Promise&lt;U&gt;((resolve, reject) =&gt; {" line56="                this.thenHandlers.push(value =&gt; {" line57="                    try {" line58="                        resolve(onFulfilled(value) as any);" line59="                    } catch (error2) {" line60="                        reject(error2);" line61="                    }" line62="                });" line63="                if (this.state === 'fulfilled' &amp;&amp; this.value !== undefined) {" line64="                    resolve(onFulfilled(this.value) as any);" line65="                }" line66="            });" line67="        };" line68="" line69="        /**" line70="         * Sets a callback for when the promise rejects" line71="         * @param onFulfilled The function to run when the promise fails" line72="         * @returns { Promise&lt;U&gt; } The promise of the promise failure" line73="         */" line74="        catch&lt;U&gt;(onRejected: CatchHandler&lt;U&gt;): Promise&lt;U&gt; {" line75="            return new Promise&lt;U&gt;((resolve, reject) =&gt; {" line76="                this.catchHandler = reason =&gt; {" line77="                    try {" line78="                        resolve(onRejected(reason) as any);" line79="                    } catch (error3) {" line80="                        reject(error3);" line81="                    };" line82="                };" line83="                if (this.state === 'rejected' &amp;&amp; this.reason !== undefined) {" line84="                    resolve(onRejected(this.reason) as any);" line85="                }" line86="            });" line87="        };" line88="        private value?: T;" line89="        private reason?: any;" line90="        private state: 'pending' | 'fulfilled' | 'rejected' = 'pending';" line91="        private thenHandlers: ThenHandler&lt;T, any&gt;[] = [];" line92="        private catchHandler?: CatchHandler&lt;any&gt;;" line93="    };" line94="}" numlines="95"></mutation></block></statement></block></xml>